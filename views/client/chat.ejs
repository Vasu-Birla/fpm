<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat</title>

    <!-- âœ… Socket.IO client -->
    <script src="/socket.io/socket.io.js"></script>

    <!-- âœ… CSRF -->
    <meta name="csrf-token" content="<%= typeof csrfToken !== 'undefined' ? csrfToken : '' %>" />

    <!-- âœ… kilToast + kil-loader -->
    <script src="https://cdn.jsdelivr.net/npm/kiltoast@1.0.16/kiltoast.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/kil-loader@1.0.3/kil-loader.min.js"></script>

    <style>
      :root {
        --bg: #0f172a;
        --bg-alt: #020617;
        --sidebar-bg: #020617;
        --accent: #1b8680;
        --accent-soft: rgba(34, 197, 94, 0.1);
        --text-main: #e5e7eb;
        --text-muted: #9ca3af;
        --bubble-me: #1b8680;
        --bubble-them: #111827;
        --border-subtle: #1f2937;
        --input-bg: #020617;
        --time-color: rgba(226, 232, 240, 0.85);
        --time-color-muted: rgba(148, 163, 184, 0.85);
        --divider-line: rgba(148, 163, 184, 0.35);
      }
      body.light {
        --bg: #f5f7fb;
        --bg-alt: #ffffff;
        --sidebar-bg: #f8fafc;
        --accent: #159a57;
        --accent-soft: rgba(21, 154, 87, 0.12);
        --text-main: #0f172a;
        --text-muted: #64748b;
        --bubble-me: #159a57;
        --bubble-them: #f1f5f9;
        --border-subtle: #e2e8f0;
        --input-bg: #ffffff;
        --time-color: rgba(15, 23, 42, 0.6);
        --time-color-muted: rgba(100, 116, 139, 0.75);
        --divider-line: rgba(100, 116, 139, 0.3);
      }
      * { box-sizing: border-box; margin: 0; padding: 0; }
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: radial-gradient(circle at top, #1e293b, #020617 40%);
        color: var(--text-main);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
      }
      body.light {
        background: radial-gradient(circle at top, #ffffff, #e2e8f0 55%);
      }
      .app-wrapper {
        width: min(1100px, 100vw - 2rem);
        height: min(700px, 100vh - 2rem);
        background: var(--bg-alt);
        border-radius: 24px;
        overflow: hidden;
        border: 1px solid rgba(148, 163, 184, 0.25);
        box-shadow: 0 35px 80px rgba(15, 23, 42, 0.8);
        display: flex;
      }
      .sidebar {
        width: 30%;
        background: var(--sidebar-bg);
        border-right: 1px solid var(--border-subtle);
        display: flex;
        flex-direction: column;
      }
      .sidebar-header {
        padding: 1.25rem 1rem 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        border-bottom: 1px solid var(--border-subtle);
      }
      .app-title {
        font-size: 1rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }
      .badge {
        font-size: 0.7rem;
        padding: 0.1rem 0.4rem;
        border-radius: 999px;
        background: var(--accent-soft);
        color: var(--accent);
        border: 1px solid rgba(34, 197, 94, 0.3);
      }
      .theme-toggle {
        border-radius: 999px;
        padding: 0.35rem 0.65rem;
        border: 1px solid var(--border-subtle);
        background: transparent;
        color: var(--text-muted);
        font-size: 0.75rem;
        cursor: pointer;
      }
      .theme-toggle:hover { border-color: var(--accent); color: var(--accent); }
      .sidebar-actions { display: flex; align-items: center; gap: 0.4rem; }
      .sidebar-search { padding: 0.5rem 0.75rem 0.75rem; }
      .search-input {
        width: 100%;
        padding: 0.45rem 0.75rem;
        border-radius: 999px;
        border: 1px solid var(--border-subtle);
        background: var(--bg-alt);
        color: var(--text-main);
        font-size: 0.8rem;
        outline: none;
      }
      .search-input::placeholder { color: var(--text-muted); }
      .chat-list { flex: 1; overflow-y: auto; padding: 0.25rem 0.25rem 0.75rem; }
      .chat-item {
        display: flex;
        gap: 0.6rem;
        padding: 0.6rem 0.6rem;
        margin: 0.1rem 0.4rem;
        border-radius: 999px;
        cursor: pointer;
        transition: background 0.3s ease;
        align-items: center;
      }
      .chat-item:hover { background: rgba(15, 23, 42, 0.6); }
      body.light .chat-item:hover { background: rgba(15, 23, 42, 0.05); }
      .chat-item.active { background: var(--accent-soft); }
      .avatar {
        width: 32px; height: 32px; border-radius: 999px;
        background: linear-gradient(135deg, #0ea5e9, #22c55e);
        display: flex; align-items: center; justify-content: center;
        font-size: 0.8rem; font-weight: 600; color: white; flex-shrink: 0;
      }
      .chat-item-text { flex: 1; min-width: 0; }
      .chat-name { font-size: 0.85rem; font-weight: 500; }
      .chat-last-msg {
        font-size: 0.75rem; color: var(--text-muted);
        white-space: nowrap; text-overflow: ellipsis; overflow: hidden;
      }
      .chat-meta { font-size: 0.7rem; color: var(--time-color-muted); text-align: right; }
      .chat-unread {
        margin-top: 0.2rem;
        min-width: 18px;
        padding: 0.1rem 0.35rem;
        border-radius: 999px;
        background: var(--accent);
        color: white;
        font-size: 0.65rem;
        text-align: center;
        display: inline-block;
      }
      .chat-main {
        flex: 1; display: flex; flex-direction: column;
        background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.07), transparent 40%), var(--bg);
      }
      .chat-header {
        padding: 0.9rem 1.1rem;
        display: flex; align-items: center; justify-content: space-between;
        border-bottom: 1px solid var(--border-subtle);
        backdrop-filter: blur(10px);
        background: rgba(15, 23, 42, 0.75);
      }
      body.light .chat-header { background: rgba(248, 250, 252, 0.9); }
      .chat-header-main { display: flex; align-items: center; gap: 0.75rem; }
      .chat-header-text { display: flex; flex-direction: column; gap: 0.15rem; }
      .chat-header-name { font-size: 0.95rem; font-weight: 500; }
      .chat-header-status { font-size: 0.75rem; color: var(--text-muted); min-height: 14px; }
      .status-online { color: #39ff9a; text-shadow: 0 0 6px rgba(57, 255, 154, 0.5); }
      .chat-header-right { font-size: 0.75rem; color: var(--text-muted); display: flex; gap: 1rem; align-items: center; }
      .pill { border-radius: 999px; border: 1px solid var(--border-subtle); padding: 0.2rem 0.55rem; font-size: 0.7rem; }
      .messages {
        flex: 1; padding: 1rem 1.1rem; overflow-y: auto;
        display: flex; flex-direction: column; gap: 0.5rem;
        scroll-behavior: smooth;
      }
      .day-divider {
        text-align: center; font-size: 0.7rem; color: var(--time-color-muted);
        margin: 0.75rem 0; position: relative;
      }
      .day-divider::before, .day-divider::after {
        content: ""; position: absolute; top: 50%;
        width: 30%; height: 1px; background: var(--divider-line);
      }
      .day-divider::before { left: 0; }
      .day-divider::after { right: 0; }
      .message-row { display: flex; width: 100%; }
      .message-row.me { justify-content: flex-end; }
      .message-bubble {
        max-width: 70%;
        padding: 0.5rem 0.7rem 0.3rem;
        border-radius: 1rem;
        font-size: 0.8rem; line-height: 1.35;
        position: relative;
        word-wrap: break-word;
        white-space: pre-wrap;
      }
      .message-row.me .message-bubble {
        background: var(--bubble-me);
        color: #ecfdf5;
        border-bottom-right-radius: 0.25rem;
      }
      .message-row.them .message-bubble {
        background: var(--bubble-them);
        border-bottom-left-radius: 0.25rem;
        color: var(--text-main);
        border: 1px solid rgba(148, 163, 184, 0.2);
      }
      body.light .message-row.them .message-bubble { border-color: rgba(148, 163, 184, 0.4); }
      .message-meta {
        font-size: 0.65rem;
        color: var(--time-color);
        margin-top: 0.2rem;
        text-align: right;
        opacity: 0.9;
      }
      .message-row.them .message-meta { color: var(--time-color-muted); }
      .chat-input-area {
        padding: 0.6rem 0.8rem;
        border-top: 1px solid var(--border-subtle);
        background: rgba(15, 23, 42, 0.96);
        display: flex; align-items: center; gap: 0.55rem;
      }
      body.light .chat-input-area { background: rgba(248, 250, 252, 0.98); }
      .chat-input-container {
        flex: 1;
        display: flex; align-items: center; gap: 0.45rem;
        background: var(--input-bg);
        border-radius: 999px;
        border: 1px solid var(--border-subtle);
        padding: 0.4rem 0.7rem;
      }
      .chat-input {
        border: none; outline: none; background: transparent; flex: 1;
        color: var(--text-main); font-size: 0.85rem;
      }
      .chat-input::placeholder { color: var(--text-muted); }
      .send-btn {
        border-radius: 999px;
        padding: 0.4rem 0.9rem;
        border: none;
        background: var(--accent);
        color: white;
        font-size: 0.8rem;
        font-weight: 500;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 0.3rem;
      }
      .send-btn:disabled { opacity: 0.5; cursor: default; }
      .send-btn span.icon { font-size: 0.9rem; }

      .pending-attachments {
        padding: 0.45rem 0.8rem 0;
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }
      .pending-attachments:empty { display: none; }
      .pending-item {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.25rem 0.5rem;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.6);
        border: 1px solid var(--border-subtle);
        font-size: 0.7rem;
        color: var(--text-main);
      }
      body.light .pending-item { background: #f8fafc; }
      .pending-remove {
        border: none;
        background: transparent;
        color: var(--text-muted);
        cursor: pointer;
        font-size: 0.75rem;
      }

      .attachment-list {
        margin-top: 0.35rem;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .attachment-card {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        padding: 0.4rem 0.5rem;
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.4);
        border: 1px solid rgba(148, 163, 184, 0.2);
      }
      body.light .attachment-card {
        background: #f8fafc;
        border-color: #e2e8f0;
      }
      .attachment-card.attachment-media-card {
        flex-direction: column;
        align-items: flex-start;
      }
      .attachment-image-wrap {
        position: relative;
        display: inline-flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .attachment-media.is-loading { filter: blur(2px); }
      .attachment-loader {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(2, 6, 23, 0.55);
        color: var(--text-muted);
        font-size: 0.7rem;
        border-radius: 12px;
      }
      body.light .attachment-loader { background: rgba(248, 250, 252, 0.85); }
      .loader-dot {
        width: 18px;
        height: 18px;
        border-radius: 999px;
        border: 2px solid rgba(148, 163, 184, 0.7);
        border-top-color: transparent;
        animation: spin 0.9s linear infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      .file-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 42px;
        padding: 0.2rem 0.45rem;
        border-radius: 10px;
        font-size: 0.65rem;
        font-weight: 600;
        background: var(--accent-soft);
        color: var(--accent);
        border: 1px solid rgba(34, 197, 94, 0.3);
      }
      .attachment-name {
        font-size: 0.7rem;
        color: var(--text-main);
        max-width: 220px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .attachment-size {
        font-size: 0.65rem;
        color: var(--text-muted);
      }
      .attachment-link {
        font-size: 0.65rem;
        color: var(--accent);
        text-decoration: none;
        border: 1px solid var(--border-subtle);
        padding: 0.2rem 0.5rem;
        border-radius: 999px;
      }
      .attachment-media {
        max-width: 220px;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }
      body.light .attachment-media { border-color: rgba(148, 163, 184, 0.35); }
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(2, 6, 23, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 20;
      }
      .modal-overlay.show { display: flex; }
      .modal {
        width: min(520px, 92vw);
        background: var(--bg-alt);
        border-radius: 18px;
        border: 1px solid var(--border-subtle);
        box-shadow: 0 30px 80px rgba(15, 23, 42, 0.7);
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }
      .modal-title { font-size: 0.95rem; font-weight: 600; }
      .modal-body {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        max-height: 55vh;
        overflow-y: auto;
      }
      .user-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        border: 1px solid var(--border-subtle);
        border-radius: 12px;
        padding: 0.5rem 0.6rem;
      }
      .user-meta {
        display: flex;
        flex-direction: column;
        gap: 0.1rem;
        min-width: 0;
      }
      .user-name { font-size: 0.85rem; font-weight: 500; }
      .user-email {
        font-size: 0.7rem;
        color: var(--text-muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .user-btn {
        border-radius: 999px;
        border: none;
        background: var(--accent);
        color: white;
        font-size: 0.75rem;
        padding: 0.35rem 0.75rem;
        cursor: pointer;
      }
      .user-btn:disabled { opacity: 0.6; cursor: default; }

      @media (max-width: 800px) {
        .app-wrapper { height: 100vh; width: 100vw; border-radius: 0; }
      }
      @media (max-width: 700px) {
        .sidebar { display: none; }
      }
    </style>
  </head>

  <body>
    <div class="app-wrapper">
      <!-- Sidebar -->
      <aside class="sidebar">
        <div class="sidebar-header">
          <div class="app-title">
            <span>Chat</span>
            <span class="badge">Live</span>
          </div>
          <div class="sidebar-actions">
            <button class="theme-toggle" id="addChatBtn" title="New chat">+</button>
            <button class="theme-toggle" id="themeToggle" title="Toggle theme">&#9790; / &#9728;</button>
          </div>
        </div>

        <div class="sidebar-search">
          <input type="text" class="search-input" placeholder="Search users..." id="searchInput" />
        </div>

        <div class="chat-list" id="chatList"></div>
      </aside>

      <!-- Main Chat -->
      <main class="chat-main">
        <header class="chat-header">
          <div class="chat-header-main">
            <div class="avatar" id="activeAvatar">--</div>
            <div class="chat-header-text">
              <div class="chat-header-name" id="activeName">Select a client</div>
              <div class="chat-header-status" id="activeStatus"></div>
            </div>
          </div>
          <div class="chat-header-right">
            <span class="pill" id="activeMeta"></span>
          </div>
        </header>

        <section class="messages" id="messages"></section>

        <div class="pending-attachments" id="pendingAttachments"></div>

        <section class="chat-input-area">
          <div class="chat-input-container">
            <button class="theme-toggle" id="attachBtn" title="Attach">ðŸ“Ž</button>
            <input type="file" id="fileInput" style="display:none" multiple />
            <input type="text" class="chat-input" id="messageInput" placeholder="Type a message and press Enterâ€¦" />
          </div>

          <button class="send-btn" id="sendBtn">
            <span class="icon">âž¤</span>
            <span>Send</span>
          </button>
        </section>
      </main>
    </div>

    <div class="modal-overlay" id="userModal">
      <div class="modal">
        <div class="modal-header">
          <div class="modal-title">Start a conversation</div>
          <button class="theme-toggle" id="userModalClose">Close</button>
        </div>
        <input type="text" class="search-input" id="userSearchInput" placeholder="Search clients..." />
        <div class="modal-body" id="userList"></div>
      </div>
    </div>







  </body>
</html>




    <!-- âœ… Server injects ME -->
    <script>
      window.ME = <%- JSON.stringify(me || null) %>;
    </script>

    <script>
      // âœ… Toast config (use only kilToast.info(msg) and kilToast.danger(msg))
      try {
        kilToast.configure({
          position: 'top-right',
          duration: 3000,
          gap: 12,
          offset: 18,
          mode: 'simple'
        });
      } catch(e) {}
    </script>


<script>

    
let csrfToken = 
  (document.querySelector('input[name="_csrf"]')?.value) ||
  (document.querySelector('meta[name="csrf-token"]')?.content) ||
  null;

if (!csrfToken) console.error("âŒ CSRF token not found!");




    let axiosElaw;

/* ---------- CSRF + fetch wrapper (uses current token every time) ---------- */
(function () {
  function readCookie(name){
    return document.cookie.split('; ').find(r => r.startsWith(name+'='))?.split('=').slice(1).join('=');
  }

  // Update token in <meta> and the first hidden input[name="_csrf"], if present
  window.setCsrf = function(token){
    if(!token) return;
    let m = document.querySelector('meta[name="csrf-token"]');
    if(!m){
      m = document.createElement('meta');
      m.setAttribute('name', 'csrf-token');
      document.head.appendChild(m);
    }
    m.setAttribute('content', token);
    const hidden = document.querySelector('input[name="_csrf"]');
    if (hidden) hidden.value = token;
  };

  // Read token from meta â†’ hidden input â†’ cookie (common names)
  window.getCsrf = function(){
    const meta = document.querySelector('meta[name="csrf-token"]')?.content;
    if (meta) return meta;
    const hidden = document.querySelector('input[name="_csrf"]')?.value;
    if (hidden) return hidden;
    for (const key of ['XSRF-TOKEN','_csrf','csrfToken']) {
      const v = readCookie(key);
      if (v) return decodeURIComponent(v);
    }
    return '';
  };

  // fetch() wrapper that injects CSRF and refreshes it if server rotates
  const _fetch = window.fetch;
  window.kFetch = function(url, opts = {}) {
    const headers = new Headers(opts.headers || {});
    const t = getCsrf();
    if (t) {
      headers.set('X-CSRF-Token', t);
      headers.set('CSRF-Token', t);       // compatibility
      headers.set('X-XSRF-TOKEN', t);     // compatibility
    }
    opts.headers = headers;



    return _fetch(url, opts).then(res => {
      const newT = res.headers.get('x-csrf-token')
              || res.headers.get('csrf-token')
              || res.headers.get('x-xsrf-token');
      if (newT) setCsrf(newT);
      return res;
    }).finally(() => {
    
    });
  };

  // axios (optional) â€“ keep token fresh too
  if (window.axios) {
  const instance = axios.create();

  instance.interceptors.request.use(cfg => {
    const t = getCsrf();
    if (t) {
      cfg.headers['X-CSRF-Token'] = t;
      cfg.headers['CSRF-Token'] = t;
      cfg.headers['X-XSRF-TOKEN'] = t;
    }
    return cfg;
  });

  instance.interceptors.response.use(res => {
    const nt = res.headers['x-csrf-token'] || res.headers['csrf-token'] || res.headers['x-xsrf-token'];
    if (nt) setCsrf(nt);
    return res;
  });

  // Freeze it so no other script can overwrite accidentally
  window.axiosElaw = Object.freeze(instance);
}



})();
</script>



<script>
(() => {
  const me = window.ME;
  const chatListEl = document.getElementById("chatList");
  const messagesEl = document.getElementById("messages");
  const messageInputEl = document.getElementById("messageInput");
  const sendBtnEl = document.getElementById("sendBtn");
  const themeToggleEl = document.getElementById("themeToggle");
  const searchInputEl = document.getElementById("searchInput");
  const activeNameEl = document.getElementById("activeName");
  const activeStatusEl = document.getElementById("activeStatus");
  const activeMetaEl = document.getElementById("activeMeta");
  const activeAvatarEl = document.getElementById("activeAvatar");
  const attachBtnEl = document.getElementById("attachBtn");
  const fileInputEl = document.getElementById("fileInput");
  const pendingAttachmentsEl = document.getElementById("pendingAttachments");
  const addChatBtnEl = document.getElementById("addChatBtn");
  const userModalEl = document.getElementById("userModal");
  const userModalCloseEl = document.getElementById("userModalClose");
  const userListEl = document.getElementById("userList");
  const userSearchInputEl = document.getElementById("userSearchInput");

  const state = {
    conversations: [],
    activeConvoId: null,
    messagesByConvo: new Map(),
    messageIdsByConvo: new Map(),
    typingTimers: new Map(),
    userDirectory: [],
    userDirectoryLoaded: false,
    pendingFiles: [],
  };

  function showError(message) {
    if (!message) return;
    try {
      if (window.kilToast) kilToast.danger(String(message));
    } catch (_) {}
  }

  function getUserName(user) {
    return user?.name || user?.email || "Client";
  }

  function renderUserDirectory() {
    if (!userListEl) return;
    const term = (userSearchInputEl?.value || "").trim().toLowerCase();
    const list = term
      ? state.userDirectory.filter((u) => getUserName(u).toLowerCase().includes(term))
      : state.userDirectory;

    userListEl.innerHTML = "";

    if (!list.length) {
      const empty = document.createElement("div");
      empty.className = "user-item";
      empty.textContent = "No clients available";
      userListEl.appendChild(empty);
      return;
    }

    list.forEach((user) => {
      const item = document.createElement("div");
      item.className = "user-item";

      const left = document.createElement("div");
      left.style.display = "flex";
      left.style.alignItems = "center";
      left.style.gap = "0.6rem";

      const avatar = document.createElement("div");
      avatar.className = "avatar";
      avatar.textContent = getInitials(getUserName(user));

      const meta = document.createElement("div");
      meta.className = "user-meta";

      const nameEl = document.createElement("div");
      nameEl.className = "user-name";
      nameEl.textContent = getUserName(user);

      const emailEl = document.createElement("div");
      emailEl.className = "user-email";
      emailEl.textContent = user.email || "";

      meta.appendChild(nameEl);
      meta.appendChild(emailEl);
      left.appendChild(avatar);
      left.appendChild(meta);

      const btn = document.createElement("button");
      btn.className = "user-btn";
      btn.textContent = "Start";
      btn.addEventListener("click", async () => {
        btn.disabled = true;
        await startDirectConversation(user);
        btn.disabled = false;
      });

      item.appendChild(left);
      item.appendChild(btn);
      userListEl.appendChild(item);
    });
  }

  async function loadUserDirectory() {
    try {
      const res = await kFetch("/chat/users");
      const data = await res.json();
      if (!data?.success) {
        showError(data?.message || "Failed to load users");
        return;
      }
      state.userDirectory = data.users || [];
      state.userDirectoryLoaded = true;
      renderUserDirectory();
    } catch (e) {
      console.error("loadUserDirectory error:", e);
      showError("Failed to load users");
    }
  }

  function openUserModal() {
    if (!userModalEl) return;
    userModalEl.classList.add("show");
    if (!state.userDirectoryLoaded) {
      loadUserDirectory();
    } else {
      renderUserDirectory();
    }
  }

  function closeUserModal() {
    if (!userModalEl) return;
    userModalEl.classList.remove("show");
  }

  async function startDirectConversation(user) {
    try {
      if (!user?.user_id || !user?.user_type) {
        showError("Invalid user");
        return;
      }
      const res = await emitWithAck("chat:direct", {
        other_user_id: user.user_id,
        other_user_type: user.user_type,
      });
      if (!res?.ok) {
        showError(res?.message || "Failed to start conversation");
        return;
      }
      closeUserModal();
      await refreshList();
      if (res.convo_id) {
        openConversation(res.convo_id);
      }
    } catch (e) {
      console.error("startDirectConversation error:", e);
      showError("Failed to start conversation");
    }
  }

  if (!me) {
    console.error("ME not found on page");
    showError("User not identified");
    return;
  }

  const socket = io();

  function emitWithAck(event, payload, timeoutMs = 10000) {
    if (!socket.connected) {
      return Promise.resolve({ ok: false, message: "Socket disconnected" });
    }
    return new Promise((resolve) => {
      let done = false;
      const timer = setTimeout(() => {
        if (done) return;
        done = true;
        resolve({ ok: false, message: "Request timeout" });
      }, timeoutMs);

      socket.emit(event, payload, (res) => {
        if (done) return;
        done = true;
        clearTimeout(timer);
        resolve(res || { ok: true });
      });
    });
  }

  function getConversation(convoId) {
    return state.conversations.find((c) => Number(c.convo_id) === Number(convoId));
  }

  function isFromMe(message) {
    return (
      message &&
      message.sender_type === me.user_type &&
      Number(message.sender_id) === Number(me.user_id)
    );
  }

  function formatTime(iso) {
    if (!iso) return "";
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return "";
    return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  }

  function isSameDay(a, b) {
    return (
      a.getFullYear() === b.getFullYear() &&
      a.getMonth() === b.getMonth() &&
      a.getDate() === b.getDate()
    );
  }

  function dateKey(iso) {
    if (!iso) return "";
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return "";
    return `${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}`;
  }

  function formatDateLabel(iso) {
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return "";
    const today = new Date();
    if (isSameDay(d, today)) return "Today";
    const yesterday = new Date();
    yesterday.setDate(today.getDate() - 1);
    if (isSameDay(d, yesterday)) return "Yesterday";
    return d.toLocaleDateString([], { year: "numeric", month: "short", day: "numeric" });
  }

  function appendDateDivider(label) {
    if (!messagesEl || !label) return;
    const divider = document.createElement("div");
    divider.className = "day-divider";
    divider.textContent = label;
    messagesEl.appendChild(divider);
  }

  function formatFileSize(bytes) {
    const size = Number(bytes || 0);
    if (!size) return "";
    if (size < 1024) return `${size} B`;
    if (size < 1024 * 1024) return `${(size / 1024).toFixed(1)} KB`;
    if (size < 1024 * 1024 * 1024) return `${(size / (1024 * 1024)).toFixed(1)} MB`;
    return `${(size / (1024 * 1024 * 1024)).toFixed(1)} GB`;
  }

  function getFileLabel(att) {
    const name = (att?.file_name || "").toLowerCase();
    const mime = (att?.mime_type || "").toLowerCase();
    const ext = name.includes(".") ? name.split(".").pop() : "";
    if (mime.includes("pdf") || ext === "pdf") return "PDF";
    if (mime.includes("word") || ext === "doc" || ext === "docx") return "DOC";
    if (mime.includes("excel") || ext === "xls" || ext === "xlsx") return "XLS";
    if (mime.includes("powerpoint") || ext === "ppt" || ext === "pptx") return "PPT";
    if (mime.startsWith("audio/") || ext === "mp3" || ext === "wav") return "AUDIO";
    if (mime.startsWith("video/") || ext === "mp4" || ext === "mov") return "VIDEO";
    if (mime.includes("zip") || ext === "zip" || ext === "rar" || ext === "7z") return "ZIP";
    return (ext || "FILE").toUpperCase();
  }

  let imageObserver = null;
  function ensureImageObserver() {
    if (imageObserver) return imageObserver;
    if (!("IntersectionObserver" in window)) return null;
    imageObserver = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) return;
        const img = entry.target;
        const src = img.dataset.src;
        if (src) {
          img.src = src;
          img.removeAttribute("data-src");
        }
        imageObserver.unobserve(img);
      });
    }, { rootMargin: "120px" });
    return imageObserver;
  }

  function attachImageLoader(img, loader, src) {
    img.classList.add("is-loading");
    img.dataset.src = src;
    img.addEventListener("load", () => {
      img.classList.remove("is-loading");
      if (loader) loader.remove();
    });
    img.addEventListener("error", () => {
      if (loader) loader.textContent = "Failed to load";
    });

    const observer = ensureImageObserver();
    if (observer) observer.observe(img);
    else img.src = src;
  }

  function renderPendingAttachments() {
    if (!pendingAttachmentsEl) return;
    pendingAttachmentsEl.innerHTML = "";
    if (!state.pendingFiles.length) return;

    state.pendingFiles.forEach((file, index) => {
      const item = document.createElement("div");
      item.className = "pending-item";
      item.textContent = `${file.name} ${formatFileSize(file.size) ? `(${formatFileSize(file.size)})` : ""}`.trim();

      const removeBtn = document.createElement("button");
      removeBtn.className = "pending-remove";
      removeBtn.textContent = "x";
      removeBtn.addEventListener("click", () => {
        state.pendingFiles.splice(index, 1);
        renderPendingAttachments();
      });

      item.appendChild(removeBtn);
      pendingAttachmentsEl.appendChild(item);
    });
  }

  function clearPendingAttachments() {
    state.pendingFiles = [];
    if (fileInputEl) fileInputEl.value = "";
    renderPendingAttachments();
  }

  async function uploadPendingAttachments() {
    if (!state.pendingFiles.length) return [];
    const formData = new FormData();
    state.pendingFiles.forEach((file) => formData.append("files", file));

    const res = await kFetch("/chat/upload", {
      method: "POST",
      body: formData,
    });
    const data = await res.json();
    if (!data?.success) {
      throw new Error(data?.message || "Upload failed");
    }
    return data.attachments || [];
  }
  function getInitials(name) {
    if (!name) return "--";
    const parts = name.trim().split(/\s+/).filter(Boolean);
    const first = parts[0]?.[0] || "";
    const last = parts.length > 1 ? parts[parts.length - 1][0] : "";
    return (first + last).toUpperCase() || "--";
  }

  function renderChatList() {
    if (!chatListEl) return;
    const term = (searchInputEl?.value || "").trim().toLowerCase();
    const list = term
      ? state.conversations.filter((c) => (c.title || "").toLowerCase().includes(term))
      : state.conversations;

    chatListEl.innerHTML = "";

    if (!list.length) {
      const empty = document.createElement("div");
      empty.className = "chat-item";
      empty.textContent = "No conversations yet";
      chatListEl.appendChild(empty);
      return;
    }

    list.forEach((conv) => {
      const item = document.createElement("div");
      item.className = "chat-item";
      if (Number(conv.convo_id) === Number(state.activeConvoId)) {
        item.classList.add("active");
      }
      item.dataset.id = conv.convo_id;

      const avatar = document.createElement("div");
      avatar.className = "avatar";
      avatar.textContent = getInitials(conv.title || conv.other?.name || "Chat");

      const textWrap = document.createElement("div");
      textWrap.className = "chat-item-text";

      const nameEl = document.createElement("div");
      nameEl.className = "chat-name";
      nameEl.textContent = conv.title || conv.other?.name || "Conversation";

      const lastMsgEl = document.createElement("div");
      lastMsgEl.className = "chat-last-msg";
      if (conv.last_message?.body) {
        lastMsgEl.textContent = conv.last_message.body;
      } else if (conv.last_message?.message_type) {
        lastMsgEl.textContent = `[${conv.last_message.message_type}]`;
      } else {
        lastMsgEl.textContent = "";
      }

      textWrap.appendChild(nameEl);
      textWrap.appendChild(lastMsgEl);

      const meta = document.createElement("div");
      meta.className = "chat-meta";
      meta.innerHTML = `<div>${formatTime(conv.last_message_at) || ""}</div>`;
      if (conv.unread_count && conv.unread_count > 0) {
        const unread = document.createElement("div");
        unread.className = "chat-unread";
        unread.textContent = conv.unread_count;
        meta.appendChild(unread);
      }

      item.appendChild(avatar);
      item.appendChild(textWrap);
      item.appendChild(meta);

      item.addEventListener("click", () => {
        openConversation(conv.convo_id);
      });

      chatListEl.appendChild(item);
    });
  }

  function renderActiveHeader() {
    const conv = getConversation(state.activeConvoId);
    if (!conv) {
      if (activeNameEl) activeNameEl.textContent = "Select a client";
      if (activeStatusEl) activeStatusEl.textContent = "";
      if (activeMetaEl) activeMetaEl.textContent = "";
      if (activeAvatarEl) activeAvatarEl.textContent = "--";
      return;
    }

    const name = conv.title || conv.other?.name || "Conversation";
    if (activeNameEl) activeNameEl.textContent = name;
    if (activeAvatarEl) activeAvatarEl.textContent = getInitials(name);
    if (activeMetaEl) activeMetaEl.textContent = `#${conv.convo_id}`;

    if (activeStatusEl) activeStatusEl.classList.remove("status-online");
    if (state.typingTimers.has(Number(conv.convo_id))) {
      if (activeStatusEl) activeStatusEl.textContent = "Typing...";
      return;
    }

    if (conv.other) {
      if (activeStatusEl) {
        activeStatusEl.textContent = conv.other.is_online ? "Online" : "Offline";
        activeStatusEl.classList.toggle("status-online", !!conv.other.is_online);
      }
    } else if (activeStatusEl) {
      activeStatusEl.textContent = "";
    }
  }

  function appendMessageRow(message) {
    if (!messagesEl) return;
    const row = document.createElement("div");
    row.className = "message-row " + (isFromMe(message) ? "me" : "them");

    const bubble = document.createElement("div");
    bubble.className = "message-bubble";

    const body =
      message.message_type && message.message_type !== "text"
        ? message.body || ""
        : message.body || "";

    if (body) {
      const textEl = document.createElement("div");
      textEl.textContent = body;
      bubble.appendChild(textEl);
    }

    const attachments = Array.isArray(message.attachments) ? message.attachments : [];
    if (attachments.length) {
      const listEl = document.createElement("div");
      listEl.className = "attachment-list";

      attachments.forEach((att) => {
        const type = att?.file_type || "file";
        const name = att?.file_name || "attachment";
        const url = att?.url || "";
        const size = formatFileSize(att?.file_size);

        if (type === "image") {
          const wrap = document.createElement("div");
          wrap.className = "attachment-image-wrap";

          const img = document.createElement("img");
          img.className = "attachment-media";
          img.alt = name;
          img.loading = "lazy";
          img.decoding = "async";

          const loader = document.createElement("div");
          loader.className = "attachment-loader";
          const dot = document.createElement("div");
          dot.className = "loader-dot";
          loader.appendChild(dot);

          attachImageLoader(img, loader, url);

          wrap.appendChild(img);
          wrap.appendChild(loader);
          listEl.appendChild(wrap);
          return;
        }

        if (type === "video") {
          const wrap = document.createElement("div");
          wrap.className = "attachment-image-wrap";

          const video = document.createElement("video");
          video.className = "attachment-media";
          video.controls = true;
          video.preload = "metadata";

          const loader = document.createElement("div");
          loader.className = "attachment-loader";
          const dot = document.createElement("div");
          dot.className = "loader-dot";
          loader.appendChild(dot);

          video.addEventListener("loadedmetadata", () => loader.remove());
          video.addEventListener("error", () => {
            loader.textContent = "Failed to load";
          });
          video.src = url;

          wrap.appendChild(video);
          wrap.appendChild(loader);
          listEl.appendChild(wrap);
          return;
        }

        const card = document.createElement("div");
        card.className = "attachment-card attachment-file";

        const metaWrap = document.createElement("div");
        metaWrap.style.display = "flex";
        metaWrap.style.flexDirection = "column";
        metaWrap.style.gap = "0.1rem";

        const badge = document.createElement("div");
        badge.className = "file-badge";
        badge.textContent = getFileLabel(att);

        const nameEl = document.createElement("div");
        nameEl.className = "attachment-name";
        nameEl.textContent = name;

        const sizeEl = document.createElement("div");
        sizeEl.className = "attachment-size";
        sizeEl.textContent = size;

        metaWrap.appendChild(badge);
        metaWrap.appendChild(nameEl);
        metaWrap.appendChild(sizeEl);

        const link = document.createElement("a");
        link.className = "attachment-link";
        link.href = url || "#";
        link.target = "_blank";
        link.rel = "noopener";
        link.textContent = "Download";
        if (name) link.setAttribute("download", name);

        card.appendChild(metaWrap);
        card.appendChild(link);
        listEl.appendChild(card);
      });

      bubble.appendChild(listEl);
    }

    const meta = document.createElement("div");
    meta.className = "message-meta";
    meta.textContent = formatTime(message.created_at);

    bubble.appendChild(meta);
    row.appendChild(bubble);
    messagesEl.appendChild(row);
  }

  function renderMessages(convoId) {
    if (!messagesEl) return;
    messagesEl.innerHTML = "";
    const messages = state.messagesByConvo.get(Number(convoId)) || [];
    let lastKey = "";
    messages.forEach((message) => {
      const key = dateKey(message.created_at);
      if (key && key !== lastKey) {
        appendDateDivider(formatDateLabel(message.created_at));
        lastKey = key;
      }
      appendMessageRow(message);
    });
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  function loadMessages(convoId, messages) {
    const list = Array.isArray(messages) ? messages : [];
    const set = new Set(list.map((m) => Number(m.message_id)).filter(Boolean));
    state.messagesByConvo.set(Number(convoId), list);
    state.messageIdsByConvo.set(Number(convoId), set);
  }

  async function refreshList() {
    try {
      const res = await emitWithAck("chat:list");
      if (!res?.ok) {
        showError(res?.message || "Failed to load conversations");
        return;
      }
      state.conversations = res.conversations || [];
      if (state.activeConvoId && !getConversation(state.activeConvoId)) {
        state.activeConvoId = null;
      }
      renderChatList();
      renderActiveHeader();

      if (!state.activeConvoId && state.conversations.length) {
        openConversation(state.conversations[0].convo_id);
      }
    } catch (e) {
      console.error("refreshList error:", e);
      showError("Failed to load conversations");
    }
  }

  async function openConversation(convoId) {
    try {
      const conv = getConversation(convoId);
      if (!conv) return;
      state.activeConvoId = Number(convoId);
      conv.unread_count = 0;
      renderChatList();
      renderActiveHeader();

      const joinRes = await emitWithAck("chat:join", { convo_id: convoId });
      if (!joinRes?.ok) {
        showError(joinRes?.message || "Join failed");
        return;
      }

      const historyRes = await emitWithAck("chat:history", { convo_id: convoId, limit: 40 });
      if (!historyRes?.ok) {
        showError(historyRes?.message || "Failed to load history");
        return;
      }

      loadMessages(convoId, historyRes.messages || []);
      renderMessages(convoId);

      const lastMessage = (historyRes.messages || []).slice(-1)[0];
      if (lastMessage && !isFromMe(lastMessage)) {
        emitWithAck("chat:read", { convo_id: convoId, message_id: lastMessage.message_id });
      }
    } catch (e) {
      console.error("openConversation error:", e);
      showError("Failed to open conversation");
    }
  }

  function applyMessage(message) {
    if (!message || !message.convo_id) return;
    const convoId = Number(message.convo_id);
    if (!convoId) return;

    const conv = getConversation(convoId);
    if (!conv) {
      refreshList();
      return;
    }

    const set = state.messageIdsByConvo.get(convoId) || new Set();
    const messageId = Number(message.message_id) || null;
    if (messageId && set.has(messageId)) return;

    if (messageId) set.add(messageId);
    const list = state.messagesByConvo.get(convoId) || [];
    const prevMessage = list[list.length - 1];
    const prevKey = prevMessage ? dateKey(prevMessage.created_at) : "";
    list.push(message);

    state.messagesByConvo.set(convoId, list);
    state.messageIdsByConvo.set(convoId, set);

    conv.last_message = message;
    conv.last_message_at = message.created_at || new Date().toISOString();
    if (!isFromMe(message) && convoId !== state.activeConvoId) {
      conv.unread_count = (conv.unread_count || 0) + 1;
    } else if (convoId === state.activeConvoId) {
      conv.unread_count = 0;
    }

    if (convoId === state.activeConvoId) {
      const newKey = dateKey(message.created_at);
      if (newKey && newKey !== prevKey) {
        appendDateDivider(formatDateLabel(message.created_at));
      }
      appendMessageRow(message);
      if (messagesEl) messagesEl.scrollTop = messagesEl.scrollHeight;
      if (!isFromMe(message)) {
        emitWithAck("chat:delivered", { convo_id: convoId, message_id: message.message_id });
        emitWithAck("chat:read", { convo_id: convoId, message_id: message.message_id });
      }
    }

    renderChatList();
    renderActiveHeader();
  }

  let typingTimeout = null;
  let typingActive = false;

  function emitTyping(eventName) {
    if (!state.activeConvoId) return;
    if (!socket.connected) return;
    socket.emit(eventName, { convo_id: state.activeConvoId });
  }

  if (messageInputEl) {
    messageInputEl.addEventListener("input", () => {
      if (!state.activeConvoId) return;
      if (!typingActive) {
        typingActive = true;
        emitTyping("chat:typing");
      }
      if (typingTimeout) clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        typingActive = false;
        emitTyping("chat:typing:stop");
      }, 800);
    });
  }

  async function sendMessage() {
    const body = messageInputEl?.value?.trim() || "";
    const hasFiles = state.pendingFiles.length > 0;
    if (!body && !hasFiles) return;
    if (!state.activeConvoId) {
      showError("Select a conversation");
      return;
    }

    messageInputEl.value = "";
    if (sendBtnEl) sendBtnEl.disabled = true;

    try {
      let attachments = [];
      if (hasFiles) {
        attachments = await uploadPendingAttachments();
        clearPendingAttachments();
      }

      const payload = {
        convo_id: state.activeConvoId,
        body,
        attachments,
      };
      if (!body && attachments.length) {
        payload.message_type = attachments.length === 1 ? attachments[0].file_type : "file";
      }

      const res = await emitWithAck("chat:send", payload);

      if (!res?.ok) {
        showError(res?.message || "Send failed");
        messageInputEl.value = body;
        if (sendBtnEl) sendBtnEl.disabled = false;
        return;
      }

      if (res.message) applyMessage(res.message);
    } catch (e) {
      console.error("sendMessage error:", e);
      showError("Send failed");
      messageInputEl.value = body;
    } finally {
      if (sendBtnEl) sendBtnEl.disabled = false;
    }
  }

  if (sendBtnEl) {
    sendBtnEl.addEventListener("click", sendMessage);
  }

  if (messageInputEl) {
    messageInputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
  }

  if (themeToggleEl) {
    themeToggleEl.addEventListener("click", () => {
      document.body.classList.toggle("light");
    });
  }

  if (attachBtnEl && fileInputEl) {
    attachBtnEl.addEventListener("click", (e) => {
      e.preventDefault();
      fileInputEl.click();
    });

    fileInputEl.addEventListener("change", (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;
      state.pendingFiles = state.pendingFiles.concat(files);
      renderPendingAttachments();
      fileInputEl.value = "";
    });
  }

  if (searchInputEl) {
    searchInputEl.addEventListener("input", renderChatList);
  }

  if (addChatBtnEl) {
    addChatBtnEl.addEventListener("click", openUserModal);
  }

  if (userModalCloseEl) {
    userModalCloseEl.addEventListener("click", closeUserModal);
  }

  if (userModalEl) {
    userModalEl.addEventListener("click", (e) => {
      if (e.target === userModalEl) closeUserModal();
    });
  }

  if (userSearchInputEl) {
    userSearchInputEl.addEventListener("input", renderUserDirectory);
  }

  socket.on("connect", async () => {
    try {
      const res = await emitWithAck("online", {
        user_id: me.user_id,
        user_type: me.user_type,
      });
      if (!res?.ok) {
        showError(res?.message || "Online failed");
        return;
      }
      await refreshList();
    } catch (e) {
      console.error("socket connect error:", e);
      showError("Socket error");
    }
  });

  socket.on("connect_error", (err) => {
    console.error("socket connect_error:", err);
    showError("Socket connection failed");
  });

  socket.on("chat:message", (payload) => {
    try {
      applyMessage(payload);
    } catch (e) {
      console.error("chat:message handler error:", e);
    }
  });

  socket.on("chat:message:new", (payload) => {
    try {
      applyMessage(payload);
    } catch (e) {
      console.error("chat:message:new handler error:", e);
    }
  });

  socket.on("chat:typing", (payload) => {
    try {
      if (!payload) return;
      if (
        payload.user_type === me.user_type &&
        Number(payload.user_id) === Number(me.user_id)
      ) {
        return;
      }
      const convoId = Number(payload.convo_id);
      if (!convoId) return;

      const existing = state.typingTimers.get(convoId);
      if (existing) clearTimeout(existing);

      const timer = setTimeout(() => {
        state.typingTimers.delete(convoId);
        if (convoId === state.activeConvoId) renderActiveHeader();
      }, 1500);

      state.typingTimers.set(convoId, timer);
      if (convoId === state.activeConvoId) renderActiveHeader();
    } catch (e) {
      console.error("chat:typing handler error:", e);
    }
  });

  socket.on("chat:typing:stop", (payload) => {
    try {
      if (!payload) return;
      const convoId = Number(payload.convo_id);
      if (!convoId) return;
      const timer = state.typingTimers.get(convoId);
      if (timer) clearTimeout(timer);
      state.typingTimers.delete(convoId);
      if (convoId === state.activeConvoId) renderActiveHeader();
    } catch (e) {
      console.error("chat:typing:stop handler error:", e);
    }
  });

  socket.on("chat:presence", (payload) => {
    try {
      if (!payload) return;
      const conv = state.conversations.find(
        (c) =>
          c.other &&
          c.other.user_type === payload.user_type &&
          Number(c.other.user_id) === Number(payload.user_id)
      );
      if (!conv || !conv.other) return;
      conv.other.is_online = !!payload.is_online;
      renderChatList();
      renderActiveHeader();
    } catch (e) {
      console.error("chat:presence handler error:", e);
    }
  });
})();
</script>
